#!/bin/sh

# fssg - Fast, Simple Static Site Generator

# MIT License
#
# Copyright (c) xlc-dev 2025
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# Description:
# fssg is a minimal, fast static site generator built with POSIX shell scripting.
# It transforms Markdown and HTML files into a website by applying templates,
# processing includes, conditionals, pagination, and recent events.
# Static assets are copied automatically, producing a ready-to-deploy dist directory.
#
# Usage: ./fssg [options]  (or ./your_script_name [options])
#   Options:
#     -h, --help     Display this help message
#     -q, --quiet    Suppress all output except errors
#     -v, --verbose  Show detailed build information
#     -n, --nocolor  Disable colored output
#     -w, --watch    Watch for changes and rebuild automatically
#     -s, --serve    Start a local Mongoose server for serving the dist directory
#     -j, --jobs     Number of background jobs to run (default: 4)

# Default settings
QUIET=0
VERBOSE=0
MAX_JOBS=4
NO_COLOR=0
WATCH=0
SERVE=0
OPEN_BROWSER=0

# Internal variables
JOB_COUNT=0

# Logging functions
log() { [ "$QUIET" -eq 0 ] && printf "${GREEN}[INFO]${NC} %s\n" "$1"; }
log_verbose() { [ "$VERBOSE" -eq 1 ] && printf "${BLUE}[DEBUG]${NC} %s\n" "$1"; }
log_warning() { [ "$QUIET" -eq 0 ] && printf "${YELLOW}[WARNING]${NC} %s\n" "$1" >&2; }
log_error() { printf "${RED}[ERROR]${NC} %s\n" "$1" >&2; }

# Wait for a job slot
wait_for_slot() {
  while [ "$JOB_COUNT" -ge "$MAX_JOBS" ]; do
    wait -n  # Wait for any background job to finish
    JOB_COUNT=$((JOB_COUNT - 1))  # Decrement after a job finishes
  done
}

# Display usage instructions
display_help() {
  echo "${GREEN}fssg Help${NC}"
  echo ""
  echo "Usage: $0 [options]"
  echo ""
  echo "${YELLOW}Options:${NC}"
  echo "  -h, --help     Display this help message"
  echo "  -q, --quiet    Suppress all output except errors"
  echo "  -v, --verbose  Show detailed build information"
  echo "  -n, --nocolor  Disable colored output"
  echo "  -w, --watch    Watch for changes in src/ and rebuild automatically"
  echo "  -s, --serve    Start a local Mongoose server for serving the dist/ directory"
  echo "  -o, --open     Open the browser automatically"
  echo "  -j, --jobs     Number of background jobs to run (default: 4)"
  echo ""
  echo "For more information, see https://github.com/xlc-dev/fssg"
}

# Parse command-line options
while [ $# -gt 0 ]; do
  case "$1" in
    -h|--help) display_help; exit 0 ;;
    -q|--quiet) QUIET=1; VERBOSE=0; shift ;;
    -v|--verbose) VERBOSE=1; QUIET=0; shift ;;
    -n|--nocolor) NO_COLOR=1; shift ;;
    -w|--watch) WATCH=1; shift ;;
    -s|--serve) SERVE=1; shift ;;
    -o|--open) OPEN_BROWSER=1; shift ;;
    -j|--jobs) MAX_JOBS="$2"; shift 2 ;;
    *) log_error "Unknown option: $1"; display_help; exit 1 ;;
  esac
done

# Color setup
if [ "$NO_COLOR" -eq 0 ]; then
  RED=$(printf '\033[0;31m')
  GREEN=$(printf '\033[0;32m')
  YELLOW=$(printf '\033[0;33m')
  BLUE=$(printf '\033[0;34m')
  NC=$(printf '\033[0m')
else
  RED=""; GREEN=""; YELLOW=""; BLUE=""; NC=""
fi

# Prepare output directory
rm -rf dist 2>/dev/null
mkdir -p dist
log_verbose "Created fresh 'dist' directory."

# Start local Mongoose server
start_mongoose() {
  # Detect OS
  case "$(uname -s)" in
    CYGWIN*|MINGW*|MSYS*) MONGOOSE_BIN="./mongoose/mongoose_windows.exe" ;;
    Linux*)     MONGOOSE_BIN="./mongoose/mongoose_linux" ;;
    Darwin*)    MONGOOSE_BIN="./mongoose/mongoose_mac" ;;
    *)          MONGOOSE_BIN="./mongoose/mongoose_linux" ;; # fallback
  esac

  if [ ! -x "$MONGOOSE_BIN" ]; then
    log_error "Mongoose binary not found for your OS! Please add it to the repo root."
    return 1
  fi

  ("$MONGOOSE_BIN" -d dist/ -v 0 &)
  MONGOOSE_PID=$!
  log "Mongoose server started at http://localhost:8000 (PID $MONGOOSE_PID)"
}

# Open the browser automatically
open_browser() {
  url="http://localhost:8000"
  case "$(uname -s)" in
    Darwin*) open "$url" ;;
    Linux*)  xdg-open "$url" ;;
    CYGWIN*|MINGW*|MSYS*) start "$url" ;;
    *) echo "Please open $url in your browser." ;;
  esac
}

# Hoist <style> blocks to <head>
process_styles() {
  infile="$1"
  outfile="$2"
  log_verbose "Processing styles for $infile"

  # Extract all <style> blocks, deduplicate, and store in $outfile.styles
  awk '
    BEGIN { in_style=0; style=""; n=0 }
    /<[sS][tT][yY][lL][eE][^>]*>/ { in_style=1; style=$0; next }
    in_style {
      style=style "\n" $0
      if ($0 ~ /<\/[sS][tT][yY][lL][eE]>/) {
        in_style=0
        # Deduplicate
        for (i=1;i<=n;i++) if (styles[i]==style) break
        if (i>n) { styles[++n]=style }
        style=""
      }
      next
    }
    END { for (i=1;i<=n;i++) print styles[i] }
  ' "$infile" > "$outfile.styles"

  # Remove all <style> blocks from body
  sed '/<[sS][tT][yY][lL][eE][^>]*>/,/<\/[sS][tT][yY][lL][eE]>/d' "$infile" > "$outfile.body"

  # Insert unique styles before </head>
  awk -v styles_file="$outfile.styles" '
    BEGIN {
      n = 0; while ((getline line < styles_file) > 0) styles[n++] = line; close(styles_file)
    }
    /<\/[hH][eE][aA][dD]>/ && !done { for (i = 0; i < n; i++) print styles[i]; done = 1 }
    { print }
  ' "$outfile.body" > "$outfile"

  rm -f "$outfile.styles" "$outfile.body"
  log_verbose "Finished hoisting unique styles into $outfile"
}

# Hoist <script> blocks to end of <body>
process_scripts() {
  infile="$1"
  outfile="$2"
  log_verbose "Processing scripts for $infile"

  # Extract all <script> blocks, deduplicate, and store in $outfile.scripts
  awk '
    BEGIN { in_script=0; script=""; n=0 }
    /<[sS][cC][rR][iI][pP][tT][^>]*>/ { in_script=1; script=$0; next }
    in_script {
      script=script "\n" $0
      if ($0 ~ /<\/[sS][cC][rR][iI][pP][tT]>/) {
        in_script=0
        # Deduplicate
        for (i=1;i<=n;i++) if (scripts[i]==script) break
        if (i>n) { scripts[++n]=script }
        script=""
      }
      next
    }
    END { for (i=1;i<=n;i++) print scripts[i] }
  ' "$infile" > "$outfile.scripts"

  # Remove all <script> blocks from body
  sed '/<[sS][cC][rR][iI][pP][tT][^>]*>/,/<\/[sS][cC][rR][iI][pP][tT]>/d' "$infile" > "$outfile.body"

  # Insert unique scripts before </body>
  awk -v scripts_file="$outfile.scripts" '
    BEGIN {
      n = 0; while ((getline line < scripts_file) > 0) scripts[n++] = line; close(scripts_file)
    }
    /<\/[bB][oO][dD][yY]>/ && !done { for (i = 0; i < n; i++) print scripts[i]; done = 1 }
    { print }
  ' "$outfile.body" > "$outfile"

  rm -f "$outfile.scripts" "$outfile.body"
  log_verbose "Finished hoisting unique scripts into $outfile"
}

# Process {{include:...}} and {{include-block:...}} directives
process_includes() {
  in_file="$1"
  out_file="$2"

  awk -v INC_DIR="src/includes" -v AWK_VERBOSE="$VERBOSE" '
    function trim(s) { gsub(/^[[:space:]]+|[[:space:]]+$/, "", s); return s }
    function load_template(fp, arr, n, line) {
      n = 0; while ((getline line < fp) > 0) arr[++n] = line; close(fp); return n
    }
    function render(arr, n, params_arr, block_content, i, key, l, outl, rest, p, pre, post, clen) {
      clen = length("{{content}}")
      for (i = 1; i <= n; i++) {
        l = arr[i]; for (key in params_arr) gsub("{{" key "}}", params_arr[key], l)
        outl = ""; rest = l
        while ((p = index(rest, "{{content}}")) > 0) {
          pre = substr(rest, 1, p - 1); post = substr(rest, p + clen)
          outl = outl pre block_content; rest = post
        }
        print outl rest
      }
    }
    function parse_tag(fulltag, s, params_str, key, value, eq_pos, val_start, quote_char, quote_end_offset) {
      s = trim(fulltag); gsub(/&quot;/, "\"", s); gsub(/&#39;/, "\047", s); gsub(/&amp;/, "&", s)
      gsub(/\n/, " ", s); gsub(/\r/, "", s);
      sub(/^.*include-block[[:space:]]*:/, "", s)
      s = trim(s)
      sub(/\}\}.*$/, "", s); s = trim(s)

      if (match(s, /^[^[:space:]]+/)) {
        filename = substr(s, RSTART, RLENGTH)
        params_str = trim(substr(s, RSTART + RLENGTH))
      } else {
        filename = ""
        params_str = ""
        if (s && AWK_VERBOSE) print "awk: Warning: No filename in tag: " s > "/dev/stderr"
      }
      delete params
      while (params_str) {
        eq_pos = index(params_str, "=")
        if (eq_pos <= 1) {
          if (AWK_VERBOSE) print "awk: Warning: Malformed param string: " params_str > "/dev/stderr"
          break
        }
        key = trim(substr(params_str, 1, eq_pos - 1))
        quote_char = substr(params_str, eq_pos + 1, 1)
        if (quote_char != "\"" && quote_char != "\047") {
            if (AWK_VERBOSE) print "awk: Warning: Parameter value not quoted: " params_str > "/dev/stderr"
            if (match(substr(params_str, eq_pos + 1), /[[:space:]]+/)) {
                value = substr(params_str, eq_pos + 1, RSTART -1)
                params_str = trim(substr(params_str, eq_pos + 1 + RLENGTH))
            } else {
                value = substr(params_str, eq_pos + 1)
                params_str = ""
            }
        } else {
            val_start = eq_pos + 2
            quote_end_offset = index(substr(params_str, val_start), quote_char)
            if (!quote_end_offset) {
              if (AWK_VERBOSE) print "awk: Warning: Missing closing quote for " quote_char " in: " params_str > "/dev/stderr"
              break
            }
            value = substr(params_str, val_start, quote_end_offset - 1)
            params_str = trim(substr(params_str, val_start + quote_end_offset))
        }
        params[key] = value
      }
    }

    BEGIN {
      state = 0
      tag_accumulator = ""
      block_content = ""
    }

    {
      line = $0

      # Robustly match opening of any directive
      if (state == 0 && match(line, /\{\{[[:space:]]*(include(-block)?|IF_|ELIF_|ELSE_|ENDIF_)/)) {
        tag_accumulator = ""
        block_content = ""
        state = 1
      }

      if (state == 1) {
        tag_accumulator = tag_accumulator (tag_accumulator ? "\n" : "") line
        # Check if closing braces are present (end of directive)
        if (tag_accumulator ~ /\}\}/) {
          # Single-line or multi-line directive complete
          # Normalize whitespace for robust parsing
          tag_norm = tag_accumulator
          gsub(/\n/, " ", tag_norm)
          gsub(/[[:space:]]+/, " ", tag_norm)
          # Handle include
          if (tag_norm ~ /\{\{[[:space:]]*include:[^}]+\}\}/) {
            # Simple include
            match(tag_norm, /\{\{[[:space:]]*include:[^}]+\}\}/)
            inc_tag = substr(tag_norm, RSTART, RLENGTH)
            f = inc_tag
            sub(/^.*include[[:space:]]*:/, "", f); sub(/\}\}.*/, "", f); fname2 = trim(f)
            path2 = INC_DIR "/" fname2
            if (system("test -f \"" path2 "\"") == 0) {
              while ((getline il < path2) > 0) print il
              close(path2)
            } else {
              if (AWK_VERBOSE) print "awk: Error: File not found for include: " path2 > "/dev/stderr"
              print inc_tag
            }
            state = 0
            next
          }
          # Handle include-block
          if (tag_norm ~ /\{\{[[:space:]]*include-block:[^}]+\}\}/) {
            # Start of include-block, now accumulate block content
            parse_tag(tag_norm)
            state = 2
            next
          }
          # Handle conditionals (pass through, or you can add your own logic)
          print tag_accumulator
          state = 0
          next
        } else {
          # Still accumulating directive
          next
        }
      }

      if (state == 2) {
        # Accumulate block content until {{endinclude}}
        if (line ~ /\{\{[[:space:]]*endinclude[[:space:]]*\}\}/) {
          # Render the block
          path3 = INC_DIR "/" filename
          if (system("test -f \"" path3 "\"") == 0) {
            tn = load_template(path3, tpl); render(tpl, tn, params, block_content)
          } else if (AWK_VERBOSE) print "awk: Error: Template file not found: " path3 > "/dev/stderr"
          state = 0
          tag_accumulator = ""
          block_content = ""
          next
        } else {
          block_content = block_content (block_content ? "\n" : "") line
          next
        }
      }

      # If not in a directive, print line as-is
      if (state == 0) print line
    }
  ' "$in_file" > "$out_file"
}

# Apply main HTML template
apply_template() {
  content_file="$1"
  output_file="$2"
  title_val="$3"
  template_path="src/template.html"

  if [ -f "$template_path" ]; then
    awk -v template_title_value="$title_val" -v content_filepath="$content_file" '
      BEGIN {
        page_content_line_count = 0
        while ((getline line < content_filepath) > 0) {
          page_content_array[++page_content_line_count] = line
        }
        close(content_filepath)

        CONTENT_TAG = "{{content}}"
        CONTENT_TAG_LEN = length(CONTENT_TAG)
        TITLE_TAG = "{{title}}"
      }
      {
        current_template_line = $0
        gsub(TITLE_TAG, template_title_value, current_template_line)

        output_for_this_template_line = ""
        remaining_part_of_template_line = current_template_line

        while ( (tag_position = index(remaining_part_of_template_line, CONTENT_TAG)) > 0 ) {
          printf "%s", substr(remaining_part_of_template_line, 1, tag_position - 1)
          for (k = 1; k <= page_content_line_count; k++) {
            print page_content_array[k]
          }
          remaining_part_of_template_line = substr(remaining_part_of_template_line, tag_position + CONTENT_TAG_LEN)
        }
        print remaining_part_of_template_line
      }
    ' "$template_path" > "$output_file"
    log_verbose "Applied template to $output_file (title=\"$template_title_value\")"
  else
    cp "$content_file" "$output_file"
    log_verbose "No template found; copied raw content to $output_file"
  fi
}

# Process conditionals IF_PAGE and IF_EXT
process_conditionals() {
  input_file="$1"
  output_file="$2"
  current_page_arg="$3"
  current_ext_arg="$4"

  awk -v current_page="$current_page_arg" \
      -v current_ext="$current_ext_arg" \
      -v AWK_VERBOSE="$VERBOSE" '
    function trim(s) { gsub(/^[[:space:]]+|[[:space:]]+$/, "", s); return s }
    function normalize_tag(tag) {
      gsub(/\n/, " ", tag)
      gsub(/[[:space:]]+/, " ", tag)
      return trim(tag)
    }
    BEGIN {
      depth = 0
      print_ok[0]   = 1
      branch_taken[0] = 0
      state = 0
      tag_accumulator = ""
    }
    {
      line = $0

      # Start of a directive
      if (state == 0 && match(line, /\{\{[[:space:]]*(IF_|ELIF_|ELSE_|ENDIF_)/)) {
        tag_accumulator = ""
        state = 1
      }

      if (state == 1) {
        tag_accumulator = tag_accumulator (tag_accumulator ? "\n" : "") line
        if (tag_accumulator ~ /\}\}/) {
          # Tag is complete
          tag_norm = normalize_tag(tag_accumulator)
          # IF_EXT
          if (tag_norm ~ /^\{\{[[:space:]]*IF_EXT:/) {
            sub(/^\{\{[[:space:]]*IF_EXT:/, "", tag_norm)
            sub(/\}\}.*$/, "", tag_norm)
            target = trim(tag_norm)
            depth++
            is_condition_met = (target == current_ext)
            print_ok[depth] = print_ok[depth-1] && is_condition_met
            branch_taken[depth] = 0
            if (print_ok[depth]) branch_taken[depth] = 1
            state = 0
            next
          }
          # ELIF_EXT
          if (tag_norm ~ /^\{\{[[:space:]]*ELIF_EXT:/) {
            sub(/^\{\{[[:space:]]*ELIF_EXT:/, "", tag_norm)
            sub(/\}\}.*$/, "", tag_norm)
            target = trim(tag_norm)
            can_take_branch = print_ok[depth-1] && !branch_taken[depth]
            is_condition_met = (target == current_ext)
            print_ok[depth] = can_take_branch && is_condition_met
            if (print_ok[depth]) branch_taken[depth] = 1
            state = 0
            next
          }
          # ELSE_EXT
          if (tag_norm ~ /^\{\{[[:space:]]*ELSE_EXT[[:space:]]*\}\}/) {
            can_take_branch = print_ok[depth-1] && !branch_taken[depth]
            print_ok[depth] = can_take_branch
            if (print_ok[depth]) branch_taken[depth] = 1
            state = 0
            next
          }
          # ENDIF_EXT
          if (tag_norm ~ /^\{\{[[:space:]]*ENDIF_EXT[[:space:]]*\}\}/) {
            depth--
            state = 0
            next
          }
          # IF_PAGE
          if (tag_norm ~ /^\{\{[[:space:]]*IF_PAGE:/) {
            sub(/^\{\{[[:space:]]*IF_PAGE:/, "", tag_norm)
            sub(/\}\}.*$/, "", tag_norm)
            target = trim(tag_norm)
            depth++
            is_condition_met = (target == current_page)
            print_ok[depth] = print_ok[depth-1] && is_condition_met
            branch_taken[depth] = 0
            if (print_ok[depth]) branch_taken[depth] = 1
            state = 0
            next
          }
          # ELIF_PAGE
          if (tag_norm ~ /^\{\{[[:space:]]*ELIF_PAGE:/) {
            sub(/^\{\{[[:space:]]*ELIF_PAGE:/, "", tag_norm)
            sub(/\}\}.*$/, "", tag_norm)
            target = trim(tag_norm)
            can_take_branch = print_ok[depth-1] && !branch_taken[depth]
            is_condition_met = (target == current_page)
            print_ok[depth] = can_take_branch && is_condition_met
            if (print_ok[depth]) branch_taken[depth] = 1
            state = 0
            next
          }
          # ELSE_PAGE
          if (tag_norm ~ /^\{\{[[:space:]]*ELSE_PAGE[[:space:]]*\}\}/) {
            can_take_branch = print_ok[depth-1] && !branch_taken[depth]
            print_ok[depth] = can_take_branch
            if (print_ok[depth]) branch_taken[depth] = 1
            state = 0
            next
          }
          # ENDIF_PAGE
          if (tag_norm ~ /^\{\{[[:space:]]*ENDIF_PAGE[[:space:]]*\}\}/) {
            depth--
            state = 0
            next
          }
          # Not a recognized conditional, print as-is
          print tag_accumulator
          state = 0
          next
        } else {
          # Still accumulating tag
          next
        }
      }

      # Print line if not inside a directive and condition is met
      if (state == 0 && print_ok[depth]) print line
    }
  ' "$input_file" > "$output_file"
}

# Parse markdown file. No, XSS isn't a problem here, since this is a SSG :)
parse_markdown() {
  awk '
    function process_inline(text, pre, post, rep, m, a, b, c) {
      # Links: [text](url)
      while (match(text, /\[[^]]+\]\([^)]*\)/)) {
        pre = substr(text, 1, RSTART-1)
        m = substr(text, RSTART, RLENGTH)
        post = substr(text, RSTART+RLENGTH)
        a = index(m, "](")
        b = substr(m, 2, a-2)
        c = substr(m, a+2, length(m)-a-2)
        if (substr(c, length(c), 1) == ")") c = substr(c, 1, length(c)-1)
        rep = "<a href=\"" c "\">" b "</a>"
        text = pre rep post
      }
      # Bold+italic: ***text*** or ___text___
      while (match(text, /\*\*\*[^*]+\*\*\*/)) {
        pre = substr(text, 1, RSTART-1)
        m = substr(text, RSTART, RLENGTH)
        post = substr(text, RSTART+RLENGTH)
        b = substr(m, 4, length(m)-6)
        rep = "<strong><em>" b "</em></strong>"
        text = pre rep post
      }
      while (match(text, /___[^_]+___/)) {
        pre = substr(text, 1, RSTART-1)
        m = substr(text, RSTART, RLENGTH)
        post = substr(text, RSTART+RLENGTH)
        b = substr(m, 4, length(m)-6)
        rep = "<strong><em>" b "</em></strong>"
        text = pre rep post
      }
      # Bold: **text** or __text__
      while (match(text, /\*\*[^*]+\*\*/)) {
        pre = substr(text, 1, RSTART-1)
        m = substr(text, RSTART, RLENGTH)
        post = substr(text, RSTART+RLENGTH)
        b = substr(m, 3, length(m)-4)
        rep = "<strong>" b "</strong>"
        text = pre rep post
      }
      while (match(text, /__[^_]+__/)) {
        pre = substr(text, 1, RSTART-1)
        m = substr(text, RSTART, RLENGTH)
        post = substr(text, RSTART+RLENGTH)
        b = substr(m, 3, length(m)-4)
        rep = "<strong>" b "</strong>"
        text = pre rep post
      }
      # Italic: *text* or _text_
      while (match(text, /\*[^*]+\*/)) {
        if (RSTART > 1 && substr(text, RSTART-1, 1) == "*") break
        if (substr(text, RSTART, 2) == "**") break
        pre = substr(text, 1, RSTART-1)
        m = substr(text, RSTART, RLENGTH)
        post = substr(text, RSTART+RLENGTH)
        b = substr(m, 2, length(m)-2)
        rep = "<em>" b "</em>"
        text = pre rep post
      }
      while (match(text, /_[^_]+_/)) {
        if (RSTART > 1 && substr(text, RSTART-1, 1) == "_") break
        if (substr(text, RSTART, 2) == "__") break
        pre = substr(text, 1, RSTART-1)
        m = substr(text, RSTART, RLENGTH)
        post = substr(text, RSTART+RLENGTH)
        b = substr(m, 2, length(m)-2)
        rep = "<em>" b "</em>"
        text = pre rep post
      }
      # Strikethrough: ~~text~~
      while (match(text, /~~[^~]+~~/)) {
        pre = substr(text, 1, RSTART-1)
        m = substr(text, RSTART, RLENGTH)
        post = substr(text, RSTART+RLENGTH)
        b = substr(m, 3, length(m)-4)
        rep = "<del>" b "</del>"
        text = pre rep post
      }
      return text
    }

    BEGIN {
      in_table = 0
      in_thead = 0
      in_tbody = 0
      in_template_block = 0
    }

    # If both start and end are on the same line, print as-is
    index($0, "{{include-block:") && index($0, "{{endinclude}}") {
      print $0
      next
    }
    # Template block start (anywhere in line, but not also end)
    index($0, "{{include-block:") {
      in_template_block = 1
      print $0
      next
    }
    # Template block end (anywhere in line, but not also start)
    index($0, "{{endinclude}}") {
      print $0
      in_template_block = 0
      next
    }
    # Inside template block: print as-is
    in_template_block { print $0; next }
    # Single-line template
    $0 ~ /^\{\{.*\}\}$/ { print $0; next }

    # HTML passthrough, but process inline markdown
    $0 ~ /^[ \t]*<.*>[ \t]*$/ {
      html_line = $0
      if (html_line ~ /\[[^]]+\]\([^)]*\)/ || html_line ~ /\*\*|__|~~|_|\*/) {
        print process_inline(html_line)
      } else {
        print html_line
      }
      next
    }

    # Table row
    $0 ~ /^\|/ {
      line = $0
      sub(/^[ \t]*\|/, "", line)
      sub(/\|[ \t]*$/, "", line)
      n = split(line, cols, /\|/)
      is_sep = 1
      for (i = 1; i <= n; i++) {
        if (cols[i] !~ /^[ \t]*-+[ \t]*$/) is_sep = 0
      }
      if (!in_table) {
        print "<table>"
        in_table = 1
        in_thead = 1
        print "<thead>"
      }
      if (is_sep) {
        if (in_thead) {
          print "</thead>"
          print "<tbody>"
          in_thead = 0
          in_tbody = 1
        }
        next
      }
      row = ""
      for (i = 1; i <= n; i++) {
        cell = process_inline(cols[i])
        if (in_thead) {
          row = row "<th>" cell "</th>"
        } else {
          row = row "<td>" cell "</td>"
        }
      }
      print "<tr>" row "</tr>"
      next
    }

    # End table if not in table and line is not a table
    {
      if (in_table && $0 !~ /^\|/) {
        if (in_tbody) print "</tbody>"
        else if (in_thead) print "</thead>"
        print "</table>"
        in_table = 0
        in_thead = 0
        in_tbody = 0
      }
    }

    # Headers
    $0 ~ /^###### / { sub(/^###### /, "", $0); print "<h6>" process_inline($0) "</h6>"; next }
    $0 ~ /^##### / { sub(/^##### /, "", $0); print "<h5>" process_inline($0) "</h5>"; next }
    $0 ~ /^#### / { sub(/^#### /, "", $0); print "<h4>" process_inline($0) "</h4>"; next }
    $0 ~ /^### / { sub(/^### /, "", $0); print "<h3>" process_inline($0) "</h3>"; next }
    $0 ~ /^## / { sub(/^## /, "", $0); print "<h2>" process_inline($0) "</h2>"; next }
    $0 ~ /^# / { sub(/^# /, "", $0); print "<h1>" process_inline($0) "</h1>"; next }

    # Horizontal rule
    $0 ~ /^---$/ { print "<hr>"; next }
    $0 ~ /^___$/ { print "<hr>"; next }
    $0 ~ /^\*\*\*$/ { print "<hr>"; next }

    # Empty lines
    $0 ~ /^[ \t]*$/ { print ""; next }

   # Regular paragraphs
    { print "<p>" process_inline($0) "</p>" }

    END {
      if (in_table) {
        if (in_tbody) print "</tbody>"
        else if (in_thead) print "</thead>"
        print "</table>"
      }
    }
  '
}

# POSIX-compliant path normalization (string manipulation)
# Input: a path string (e.g., "src/posts/../images/pic.png")
# Output: normalized path string (e.g., "src/images/pic.png")
_normalize_path_string() {
    local path="$1"
    local old_ifs="$IFS"
    local is_absolute=0
    local prefix=""

    case "$path" in
        /*) is_absolute=1; path="${path#?}"; prefix="/";;
    esac

    IFS='/'
    # shellcheck disable=SC2086 # We want word splitting here
    set -- $path
    IFS="$old_ifs"

    local components_out=""
    local component

    for component_token in "$@"; do # Use different var name to avoid conflict
        component="$component_token" # Assign to avoid issues if $@ is empty
        if [ "$component" = "." ] || [ -z "$component" ]; then
            continue
        fi
        if [ "$component" = ".." ]; then
            if [ -n "$components_out" ]; then
                components_out="${components_out%/*}"
            elif [ "$is_absolute" -eq 0 ]; then
                if [ -z "$components_out" ]; then
                    components_out=".."
                else
                    components_out="$components_out/.."
                fi
            fi
        else
            if [ -z "$components_out" ]; then
                components_out="$component"
            else
                components_out="$components_out/$component"
            fi
        fi
    done

    if [ "$is_absolute" -eq 1 ]; then
        if [ -z "$components_out" ] && [ -z "$prefix" ]; then # Path was only "/" or "/." or "/.."
             printf '/\n'
        elif [ -z "$components_out" ] && [ -n "$prefix" ]; then # Path was like "/"
             printf '/\n'
        else
             printf '/%s\n' "$components_out"
        fi
    else
        if [ -z "$components_out" ]; then
            printf '.\n'
        else
            printf '%s\n' "$components_out"
        fi
    fi
}


# collect all date-prefixed posts (ISO, EU, US) and emit sorted lines
collect_posts() {
  find src \
    -type f \
    ! -path 'src/includes/*' \
    ! -path 'src/static/*' \
    \( -name '*.md' -o -name '*.html' \) | \
  while IFS= read -r file; do
    filename=${file##*/}
    case "$filename" in
      ????-??-??-*)
        # ISO: YYYY-MM-DD-slug.ext
        date_part=${filename%%-*}
        rest=${filename#${date_part}-}
        slug=${rest%.*}
        sort_key=${date_part//-/}
        ;;
      ??_??_????-*)
        # EU: DD_MM_YYYY-slug.ext
        date_part=${filename%%-*}
        rest=${filename#${date_part}-}
        slug=${rest%.*}
        IFS=_ read -r d m y <<EOF
${date_part}
EOF
        sort_key=${y}${m}${d}
        ;;
      ??-??-????-*)
        # US: MM-DD-YYYY-slug.ext
        date_part=${filename%%-*}
        rest=${filename#${date_part}-}
        slug=${rest%.*}
        IFS=- read -r m d y <<EOF
${date_part}
EOF
        sort_key=${y}${m}${d}
        ;;
      *)
        continue
        ;;
    esac

    out_url=${file#src/}
    out_url=dist/${out_url%.*}.html
    image=""

    img_content_src=$(sed -n '
        s/.*<[iI][mM][gG][^>]*[sS][rR][cC][[:space:]]*=[[:space:]]*"\([^"]*\)".*/\1/p;
        s/.*<[iI][mM][gG][^>]*[sS][rR][cC][[:space:]]*=[[:space:]]*'\''\([^'\'']*\)''.*/\1/p;
    ' "$file" | head -n 1)


    if [ -n "$img_content_src" ]; then
        case "$img_content_src" in
            http://*|https://*|//*)
                image="$img_content_src"
                ;;
            /*)
                image="${img_content_src#/}"
                ;;
            *)
                post_dir=$(dirname -- "$file")
                if [ "$post_dir" = "." ]; then
                    combined_path="$img_content_src"
                else
                    combined_path="$post_dir/$img_content_src"
                fi

                normalized_img_path=$(_normalize_path_string "$combined_path")

                if case "$normalized_img_path" in src/*) true;; *) false;; esac; then
                    image="${normalized_img_path#src/}"
                else
                    image="$normalized_img_path"
                fi
                if [ "$image" = "." ]; then image=""; fi
                ;;
        esac
    fi

    if [ -z "$image" ]; then
        for ext in jpg jpeg png gif webp svg; do
            fallback_img_path="static/posts/${slug}.${ext}"
            if [ -f "src/$fallback_img_path" ]; then
                image="$fallback_img_path"
                break
            fi
        done
    fi

    printf '%s|%s|%s|%s|%s\n' \
      "$sort_key" "$date_part" "$slug" "$out_url" "$image"
  done | sort -r
}

# render a <ul> of either the N most recent or one page of all posts
render_posts() {
  mode=$1
  count=$2
  page=${3:-1}
  pagination=${4:-false}
  ul_class=${5:-posts}
  li_class=${6:-post}
  time_class=${7:-date}
  link_class=${8:-title}
  img_class=${9:-thumb}
  show_images=${10:-false}

  idx=$(mktemp)
  # shellcheck disable=SC2267 # POSIX compliance for mktemp
  if [ -z "$idx" ] || ! expr "$idx" : '.*/.*' >/dev/null ; then # Basic check for mktemp success
    printf "Error: mktemp failed to create a temporary file.\n" >&2
    return 1
  fi

  collect_posts >"$idx"
  total=$(wc -l <"$idx")
  total=${total%% *} # Trim leading spaces from wc output

  printf '<ul class="%s">\n' "$ul_class"

  if [ "$mode" = recent ]; then
    slice_cmd="head -n $count"
  else
    start=$(( (page - 1) * count + 1 ))
    end=$(( page * count ))
    slice_cmd="sed -n '${start},${end}p'"
  fi

  eval "$slice_cmd \"$idx\"" | \
  while IFS='|' read -r key date_part slug url image_path; do # Renamed 'image' to 'image_path'
    title=${slug//-/ }
    printf '  <li class="%s">\n' "$li_class"
    if [ "$show_images" = true ] && [ -n "$image_path" ]; then
      img_src_to_render="$image_path"
      case "$image_path" in
          http://*|https://*|//*) ;; # Use as is
          /*) # Already absolute, use as is (though collect_posts tries to avoid leading / for local)
              img_src_to_render="$image_path" ;;
          *)  # Prepend / if not a full URL and not starting with /
              img_src_to_render="/${image_path#/}" ;;
      esac
      printf '    <img class="%s" src="%s" alt="%s">\n' \
        "$img_class" "$img_src_to_render" "$title"
    fi
    printf '    <time class="%s" datetime="%s">%s</time>\n' \
      "$time_class" "$key" "$date_part"
    printf '    <a class="%s" href="/%s">%s</a>\n' \
      "$link_class" "${url#dist/}" "$title"
    printf '  </li>\n'
  done

  printf '</ul>\n'

  if [ "$mode" = all ] && [ "$pagination" = true ]; then
    if [ "$count" -gt 0 ]; then
        pages=$(( (total + count - 1) / count ))
        if [ "$pages" -gt 1 ]; then # Only show pagination if more than one page
            printf '<nav class="pagination">\n'
            # Using awk for POSIX-compliant sequence generation instead of 'seq'
            awk_prog='BEGIN { for (p = start_page; p <= total_pages; p++) printf "%d\\n", p }'
            current_page_for_awk=$page # Avoid conflict with awk var 'page'
            # shellcheck disable=SC2016 # We want $p, $current_page_for_awk to be expanded by shell
            echo "$pages" | awk -v start_page=1 -v total_pages="$pages" -v current_page="$current_page_for_awk" '
                BEGIN {
                    printf "  ";
                    for (p = 1; p <= total_pages; p++) {
                        if (p > 1) {
                            printf " ";
                        }
                        if (p == current_page) {
                            printf "<span class=\"current\">%d</span>", p;
                        } else {
                            printf "<a class=\"page\" href=\"?page=%d\">%d</a>", p, p;
                        }
                    }
                }
            '
            printf '</nav>\n'
        fi
    fi
  fi
  rm -f "$idx"
}

# replace {{recent-posts…}} and {{all-posts…}} in a file
process_post_directives() {
  in=$1; out=$2
  tmp1=$(mktemp)
  tmp2=$(mktemp)
  # shellcheck disable=SC2267 # POSIX compliance for mktemp
  if [ -z "$tmp1" ] || ! expr "$tmp1" : '.*/.*' >/dev/null || \
     [ -z "$tmp2" ] || ! expr "$tmp2" : '.*/.*' >/dev/null ; then
    printf "Error: mktemp failed to create temporary files.\n" >&2
    [ -n "$tmp1" ] && rm -f "$tmp1"
    [ -n "$tmp2" ] && rm -f "$tmp2"
    return 1
  fi


  awk '
    /\{\{(recent|all)-posts/ {
      buf = $0
      while (buf !~ /\}\}/ && getline > 0) {
        buf = buf " " $0
      }
      print buf
      next
    }
    { print }
  ' "$in" >"$tmp1"

  sed 's|<p>[[:space:]]*\({{\(recent\|all\)-posts[^}]*}}\)[[:space:]]*</p>|\1|g' \
      "$tmp1" >"$tmp2"

  : >"$out"
  while IFS= read -r line; do
    case "$line" in
      *'{{recent-posts '*)
        count=$(printf '%s\n' "$line" | sed -n 's/.*count=["]*\([0-9]\{1,\}\)["]*.*/\1/p')
        ul_class=$(printf '%s\n' "$line" | sed -n 's/.*ul_class=["]*\([^"]*\)["]*.*/\1/p')
        li_class=$(printf '%s\n' "$line" | sed -n 's/.*li_class=["]*\([^"]*\)["]*.*/\1/p')
        time_class=$(printf '%s\n' "$line" | sed -n 's/.*time_class=["]*\([^"]*\)["]*.*/\1/p')
        link_class=$(printf '%s\n' "$line" | sed -n 's/.*link_class=["]*\([^"]*\)["]*.*/\1/p')
        img_class=$(printf '%s\n' "$line" | sed -n 's/.*img_class=["]*\([^"]*\)["]*.*/\1/p')
        show_images=$(printf '%s\n' "$line" | sed -n 's/.*show_images=["]*\(\(true\)\|\(false\)\)["]*.*/\1/p')

        render_posts recent "${count:-10}" 1 false \
          "${ul_class:-posts}" "${li_class:-post}" \
          "${time_class:-date}" "${link_class:-title}" \
          "${img_class:-thumb}" "${show_images:-false}" \
          >>"$out"
        ;;

      *'{{all-posts '*)
        page_size=$(printf '%s\n' "$line" | sed -n 's/.*page_size=["]*\([0-9]\{1,\}\)["]*.*/\1/p')
        page=$(printf '%s\n' "$line" | sed -n 's/.*page=["]*\([0-9]\{1,\}\)["]*.*/\1/p')
        pagination=$(printf '%s\n' "$line" | sed -n 's/.*pagination=["]*\(\(true\)\|\(false\)\)["]*.*/\1/p')
        ul_class=$(printf '%s\n' "$line" | sed -n 's/.*ul_class=["]*\([^"]*\)["]*.*/\1/p')
        li_class=$(printf '%s\n' "$line" | sed -n 's/.*li_class=["]*\([^"]*\)["]*.*/\1/p')
        time_class=$(printf '%s\n' "$line" | sed -n 's/.*time_class=["]*\([^"]*\)["]*.*/\1/p')
        link_class=$(printf '%s\n' "$line" | sed -n 's/.*link_class=["]*\([^"]*\)["]*.*/\1/p')
        img_class=$(printf '%s\n' "$line" | sed -n 's/.*img_class=["]*\([^"]*\)["]*.*/\1/p')
        show_images=$(printf '%s\n' "$line" | sed -n 's/.*show_images=["]*\(\(true\)\|\(false\)\)["]*.*/\1/p')

        render_posts all "${page_size:-10}" "${page:-1}" "${pagination:-false}" \
          "${ul_class:-posts}" "${li_class:-post}" \
          "${time_class:-date}" "${link_class:-title}" \
          "${img_class:-thumb}" "${show_images:-false}" \
          >>"$out"
        ;;
      *)
        printf '%s\n' "$line" >>"$out"
        ;;
    esac
  done <"$tmp2"

  rm -f "$tmp1" "$tmp2"
}

# Main processing loop for source files
build() {
  while IFS= read -r file; do
    JOB_COUNT=$((JOB_COUNT + 1))
    wait_for_slot
    (
    ext="${file##*.}"
    rel_path="${file#src/}"
    out_file="dist/${rel_path%.*}.html"
    mkdir -p "$(dirname "$out_file")"
    log_verbose "Processing $file → $out_file"

    base_name=$(basename "$file" ."$ext")
    dynamic_title=$(printf '%s\n' "$base_name" | tr '-' ' ' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) tolower(substr($i,2)); print}')

    temp_raw_content="$out_file.tmp-raw"
    case "$ext" in
      md)
        if ! parse_markdown <"$file" >"$temp_raw_content" 2>"$out_file.md-err"; then
          log_warning "Custom Markdown conversion failed for $file. Error: $(cat "$out_file.md-err") Skipping."
          rm -f "$temp_raw_content" "$out_file.md-err"
          continue
        fi
        rm -f "$out_file.md-err"
        ;;
      html) cp "$file" "$temp_raw_content" ;;
    esac

    if [ ! -f "$temp_raw_content" ]; then
      log_warning "Temporary raw file $temp_raw_content not found for $file. Skipping."
      continue
    fi

    current_content_for_directives="$out_file.tmp-directives-processed"
    awk '
      BEGIN {
        in_comment = 0
        disabled_open_brace = "{^{"
        disabled_close_brace = "}^}"
      }
      {
        current_line_text = $0
        output_buffer = ""
        while (length(current_line_text) > 0) {
          if (in_comment) {
            comment_end_pos = index(current_line_text, "-->")
            if (comment_end_pos > 0) {
              text_inside_comment = substr(current_line_text, 1, comment_end_pos - 1)
              gsub(/\{\{/, disabled_open_brace, text_inside_comment)
              gsub(/\}\}/, disabled_close_brace, text_inside_comment)
              output_buffer = output_buffer text_inside_comment "-->"
              current_line_text = substr(current_line_text, comment_end_pos + 3)
              in_comment = 0
            } else {
              text_inside_comment = current_line_text
              gsub(/\{\{/, disabled_open_brace, text_inside_comment)
              gsub(/\}\}/, disabled_close_brace, text_inside_comment)
              output_buffer = output_buffer text_inside_comment
              current_line_text = ""
            }
          } else {
            comment_start_pos = index(current_line_text, "<!--")
            if (comment_start_pos > 0) {
              text_before_comment = substr(current_line_text, 1, comment_start_pos - 1)
              output_buffer = output_buffer text_before_comment "<!--"
              current_line_text = substr(current_line_text, comment_start_pos + 4)
              in_comment = 1
            } else {
              output_buffer = output_buffer current_line_text
              current_line_text = ""
            }
          }
        }
        print output_buffer
      }
    ' "$temp_raw_content" > "$current_content_for_directives"
    rm -f "$temp_raw_content"

    title_override=$(awk '
      {
        prefix_regex = "\\{\\{[[:space:]]*[Tt][Ii][Tt][Ll][Ee]:[[:space:]]*"

        if (match($0, prefix_regex)) {
          content_and_suffix = substr($0, RSTART + RLENGTH)

          if (match(content_and_suffix, "\\}\\}")) {
            title_val = substr(content_and_suffix, 1, RSTART - 1)
            gsub(/^[[:space:]]+|[[:space:]]+$/, "", title_val)
            print title_val
            exit
          }
        }
      }
    ' "$current_content_for_directives")

    temp_after_title_removal="$out_file.tmp-title-removed"
    sed 's/{{[[:space:]]*[Tt][Ii][Tt][Ll][Ee]:[^}]*}}//g' "$current_content_for_directives" > "$temp_after_title_removal"
    mv "$temp_after_title_removal" "$current_content_for_directives"

    page_id="${rel_path%.*}.html"
    current_title="${title_override:-$dynamic_title}"
    log_verbose "Title for $page_id -> \"$current_title\""

    temp_after_template="$out_file.tmp-template"
    apply_template "$current_content_for_directives" "$temp_after_template" "$current_title"
    rm -f "$current_content_for_directives"

    temp_after_conditionals="$out_file.tmp-cond"
    process_conditionals "$temp_after_template" "$temp_after_conditionals" "$page_id" "$ext"
    rm -f "$temp_after_template"

    if [ ! -f "$temp_after_conditionals" ]; then
      log_error "Conditional processing failed for $file. Output file $temp_after_conditionals not created."
      rm -f "$current_content_for_directives" "$temp_after_template"
      continue
    fi

    temp_after_includes="$out_file.tmp-includes"
    process_includes "$temp_after_conditionals" "$temp_after_includes"
    rm -f "$temp_after_conditionals"

    temp_after_posts="$out_file.tmp-posts"
    process_post_directives "$temp_after_includes" "$temp_after_posts"
    rm -f "$temp_after_includes"

    temp_after_styles="$out_file.tmp-styles"
    process_styles "$temp_after_posts" "$temp_after_styles"
    rm -f "$temp_after_posts"

    temp_no_comments="$out_file.tmp-no-comments"
    sed '/<!--.*-->/d;/^[[:space:]]*$/d' "$temp_after_styles" > "$temp_no_comments"

    intended_final_filename="dist/${rel_path%.*}.html"
    process_scripts "$temp_no_comments" "$intended_final_filename"
    rm -f "$temp_after_styles" "$temp_no_comments"

    log "Created $intended_final_filename"
  ) &
  done < <(find src \( -path src/includes -o -name template.html \) -prune -o -type f \( -name '*.md' -o -name '*.html' \) -print)

  wait # Wait for all background jobs to finish
  JOB_COUNT=0

  # Copy static assets
  if [ -d "src/static" ]; then
    mkdir -p dist/static
    cp -R src/static/* dist/static/ 2>/dev/null # Suppress errors for symlinks etc.
    log "Copied static files to dist/static/"
  else
    log_warning "No 'src/static/' directory found. Skipping static asset copy."
  fi

  log "${GREEN}Build complete!${NC} Check the 'dist' directory."
}

if [ "$WATCH" -eq 1 ]; then
  if [ "$SERVE" -eq 1 ]; then
    start_mongoose
  fi
  last_hash=""
  browser_opened=0
  while true; do
    current_hash=$(find src -type f -exec md5sum {} + 2>/dev/null | md5sum | awk '{print $1}')
    if [ "$current_hash" != "$last_hash" ]; then
      clear
      log_verbose "Change detected, rebuilding..."
      build
      last_hash="$current_hash"
      if [ "$SERVE" -eq 1 ] && [ "$OPEN_BROWSER" -eq 1 ] && [ "$browser_opened" -eq 0 ]; then
        open_browser
        browser_opened=1
      fi
    fi
    sleep 1
  done
else
  build
  if [ "$SERVE" -eq 1 ]; then
    start_mongoose
    if [ "$OPEN_BROWSER" -eq 1 ]; then
      open_browser
    fi
  fi
fi

exit 0