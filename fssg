#!/bin/sh

# -----------------------------------------------------------------------------
# fssg - Fast, Simple Static Site Generator
#
# A minimal, fast static site generator built with POSIX shell scripting.
# It transforms Markdown and HTML files into a complete website by applying
# templates, processing includes, conditionals, pagination, and events.
# Static assets are copied automatically, producing a ready-to-deploy `dist`
# directory.
#
# Usage: ./fssg [options]
#
# Options:
#   -h, --help     Display this help message
#   -q, --quiet    Suppress all output except errors
#   -v, --verbose  Show detailed build information
#   -n, --nocolor  Disable colored output
#   -w, --watch    Watch for changes and rebuild automatically
#   -o, --open     Open the browser automatically (requires -s)
#   -s, --serve    Start a local Mongoose server for serving the dist dir
#   -j, --jobs     Number of background jobs to run (default: 4)
#
# License: MIT License (see below)
#
# Copyright (c) xlc-dev 2025
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# -----------------------------------------------------------------------------

# Logging utilities
log_info()    { [ "$QUIET" -eq 0 ] && printf '%s[INFO]%s %s\n'  "$GREEN" "$NC" "$1"; }
log_verbose() { [ "$VERBOSE" -eq 1 ] && printf '%s[DEBUG]%s %s\n' "$BLUE" "$NC" "$1"; }
log_warn()    { [ "$QUIET" -eq 0 ] && printf '%s[WARN]%s %s\n'  "$YELLOW" "$NC" "$1" >&2; }
log_error()   { printf '%s[ERROR]%s %s\n' "$RED" "$NC" "$1" >&2; }

# Convert basic Markdown to HTML
parse_markdown() {
  awk '
    # process_inline(): handle inline Markdown (links, bold, italic, strike)
    function process_inline(text, pre, post, rep, m, a, b, c) {
      # links: [text](url)
      while (match(text, /\[[^]]+\]\([^)]*\)/)) {
        pre = substr(text,1,RSTART-1); m = substr(text,RSTART,RLENGTH)
        post = substr(text,RSTART+RLENGTH)
        a = index(m, "](")
        b = substr(m, 2, a-2)      # link text
        c = substr(m, a+2, length(m)-a-2)  # URL (without closing ))
        if (substr(c, length(c),1)==")") c = substr(c,1,length(c)-1)
        rep = "<a href=\"" c "\">" b "</a>"
        text = pre rep post
      }
      # bold+italic: ***text*** or ___text___
      while (match(text, /\*\*\*[^*]+\*\*\*/)) {
        pre = substr(text,1,RSTART-1); m = substr(text,RSTART,RLENGTH)
        post = substr(text,RSTART+RLENGTH)
        b = substr(m,4,length(m)-6)
        rep = "<strong><em>" b "</em></strong>"
        text = pre rep post
      }
      while (match(text, /___[^_]+___/)) {
        pre = substr(text,1,RSTART-1); m = substr(text,RSTART,RLENGTH)
        post = substr(text,RSTART+RLENGTH)
        b = substr(m,4,length(m)-6)
        rep = "<strong><em>" b "</em></strong>"
        text = pre rep post
      }
      # bold: **text** or __text__
      while (match(text, /\*\*[^*]+\*\*/)) {
        pre = substr(text,1,RSTART-1); m = substr(text,RSTART,RLENGTH)
        post = substr(text,RSTART+RLENGTH)
        b = substr(m,3,length(m)-4)
        rep = "<strong>" b "</strong>"
        text = pre rep post
      }
      while (match(text, /__[^_]+__/)) {
        pre = substr(text,1,RSTART-1); m = substr(text,RSTART,RLENGTH)
        post = substr(text,RSTART+RLENGTH)
        b = substr(m,3,length(m)-4)
        rep = "<strong>" b "</strong>"
        text = pre rep post
      }
      # italic: *text* or _text_
      while (match(text, /\*[^*]+\*/)) {
        pre = substr(text,1,RSTART-1); m = substr(text,RSTART,RLENGTH)
        post = substr(text,RSTART+RLENGTH)
        b = substr(m,2,length(m)-2)
        rep = "<em>" b "</em>"
        text = pre rep post
      }
      while (match(text, /_[^_]+_/)) {
        pre = substr(text,1,RSTART-1); m = substr(text,RSTART,RLENGTH)
        post = substr(text,RSTART+RLENGTH)
        b = substr(m,2,length(m)-2)
        rep = "<em>" b "</em>"
        text = pre rep post
      }
      # strikethrough: ~~text~~
      while (match(text, /~~[^~]+~~/)) {
        pre = substr(text,1,RSTART-1); m = substr(text,RSTART,RLENGTH)
        post = substr(text,RSTART+RLENGTH)
        b = substr(m,3,length(m)-4)
        rep = "<del>" b "</del>"
        text = pre rep post
      }
      return text
    }

    BEGIN {
      # state flags for table and include-block contexts
      in_table=0; in_thead=0; in_tbody=0; in_template_block=0
    }

    # Pass through include-block tags unchanged here
    match($0, /\{\{[[:space:]]*include-block:/) && match($0, /\{\{[[:space:]]*endinclude[[:space:]]*\}\}/) { print; next }
    match($0, /\{\{[[:space:]]*include-block:/) { in_template_block=1; print; next }
    match($0, /\{\{[[:space:]]*endinclude[[:space:]]*\}\}/) { print; in_template_block=0; next }
    in_template_block { print; next }

    # Pass through standalone template tags {{ ... }}
    /^[[:space:]]*\{\{.*\}\}[[:space:]]*$/ { print; next }

    # If line is HTML tags only, process inline markdown inside
    /^[ \t]*<.*>[ \t]*$/ { print process_inline($0); next }

    # Table row detection: lines starting with '|'
    $0 ~ /^\|/ {
      line = $0
      sub(/^[ \t]*\|/,"",line); sub(/\|[ \t]*$/,"",line)
      n = split(line, cols, /\|/)
      # Check if separator row (---|---)
      is_sep = 1
      for (i=1; i<=n; i++) {
        if (cols[i] !~ /^[ \t]*-+[ \t]*$/) is_sep=0
      }
      if (!in_table) {
        # open table
        print "<table>"
        in_table=1; in_thead=1; print "<thead>"
      }
      if (is_sep) {
        # switch from header to body
        if (in_thead) { print "</thead>"; print "<tbody>"; in_thead=0; in_tbody=1 }
        next
      }
      # render header or data cells
      row=""
      for (i=1; i<=n; i++) {
        cell = process_inline(cols[i])
        if (in_thead) row = row "<th>" cell "</th>"
        else row = row "<td>" cell "</td>"
      }
      print "<tr>" row "</tr>"
      next
    }

    # close table when non-table line encountered
    {
      if (in_table && $0 !~ /^\|/) {
        if (in_tbody) print "</tbody>"
        else if (in_thead) print "</thead>"
        print "</table>"
        in_table=0; in_thead=0; in_tbody=0
      }
    }

    # Headings H1â€“H6
    $0 ~ /^###### / { sub(/^###### /,""); print "<h6>" process_inline($0) "</h6>"; next }
    $0 ~ /^##### /  { sub(/^##### /, ""); print "<h5>" process_inline($0) "</h5>"; next }
    $0 ~ /^#### /   { sub(/^#### /,  ""); print "<h4>" process_inline($0) "</h4>"; next }
    $0 ~ /^### /    { sub(/^### /,   ""); print "<h3>" process_inline($0) "</h3>"; next }
    $0 ~ /^## /     { sub(/^## /,    ""); print "<h2>" process_inline($0) "</h2>"; next }
    $0 ~ /^# /      { sub(/^# /,     ""); print "<h1>" process_inline($0) "</h1>"; next }

    # Horizontal rules
    $0 ~ /^---$/ || $0 ~ /^___$/ || $0 ~ /^\*\*\*$/ { print "<hr>"; next }

    # Blank lines => empty output
    $0 ~ /^[ \t]*$/ { print ""; next }

    # Default: wrap in <p>
    { print "<p>" process_inline($0) "</p>" }

    END {
      # ensure any open table is closed
      if (in_table) {
        if (in_tbody) print "</tbody>"
        else if (in_thead) print "</thead>"
        print "</table>"
      }
    }
  '
}

# Inject {{ title }} and {{ content }} into template
apply_template() {
  template_path="$1"
  title_val="$2"
  awk -v template_title_value="$title_val" '
    BEGIN {
      # collect page content in array
      c=0
    }
    FILENAME=="-" {
      content[++c] = $0
      next
    }
    {
      line = $0
      # replace title placeholder
      gsub(/\{\{[[:space:]]*title[[:space:]]*\}\}/, template_title_value, line)
      # expand content placeholder
      while (match(line, /\{\{[[:space:]]*content[[:space:]]*\}\}/)) {
        printf "%s", substr(line,1,RSTART-1)
        for (i=1;i<=c;i++) print content[i]
        line = substr(line, RSTART+RLENGTH)
      }
      print line
    }
  ' - "$template_path"
}

# Handle IF_/ELIF_/ELSE_/ENDIF_ blocks
process_conditionals() {
  page_id="$1"; ext="$2"
  awk -v current_page="$page_id" -v current_ext="$ext" '
    # trim whitespace
    function trim(s) { gsub(/^[[:space:]]+|[[:space:]]+$/, "", s); return s }
    # normalize multiline tag to single line
    function normalize(tag) { gsub(/\n|[[:space:]]+/, " ", tag); return trim(tag) }
    BEGIN {
      depth=0; print_ok[0]=1; branch_taken[0]=0; state=0; tag_accumulator=""
    }
    {
      line = $0
      # detect start of a conditional tag
      if (state==0 && match(line, /\{\{[[:space:]]*(IF_|ELIF_|ELSE_|ENDIF_)/)) {
        state=1; tag_accumulator=""
      }
      if (state==1) {
        tag_accumulator = tag_accumulator (tag_accumulator? "\n":"") line
        # wait until closing }}
        if (tag_accumulator ~ /\}\}/) {
          tag_norm = normalize(tag_accumulator)
          # handle IF_EXT
          if (tag_norm ~ /^\{\{[[:space:]]*IF_EXT:/) {
            depth++; sub(/^\{\{[[:space:]]*IF_EXT:/,"",tag_norm); sub(/\}\}.*/,"",tag_norm)
            target=trim(tag_norm)
            is_met = (target==current_ext)
            print_ok[depth] = print_ok[depth-1] && is_met
            branch_taken[depth] = print_ok[depth]?1:0
          }
          # handle ELIF_EXT
          else if (tag_norm ~ /^\{\{[[:space:]]*ELIF_EXT:/) {
            sub(/^\{\{[[:space:]]*ELIF_EXT:/,"",tag_norm); sub(/\}\}.*/,"",tag_norm)
            target=trim(tag_norm)
            can_take = print_ok[depth-1] && !branch_taken[depth]
            is_met = (target==current_ext)
            print_ok[depth] = can_take && is_met
            if (print_ok[depth]) branch_taken[depth]=1
          }
          # handle ELSE_EXT
          else if (tag_norm ~ /^\{\{[[:space:]]*ELSE_EXT/) {
            can_take = print_ok[depth-1] && !branch_taken[depth]
            print_ok[depth] = can_take
            if (can_take) branch_taken[depth]=1
          }
          # handle ENDIF_EXT
          else if (tag_norm ~ /^\{\{[[:space:]]*ENDIF_EXT/) {
            depth--
          }
          # page-based variants IF_PAGE, ELIF_PAGE, etc. (same logic)
          else if (tag_norm ~ /^\{\{[[:space:]]*IF_PAGE:/) {
            depth++; sub(/^\{\{[[:space:]]*IF_PAGE:/,"",tag_norm); sub(/\}\}.*/,"",tag_norm)
            target=trim(tag_norm)
            is_met = (target==current_page)
            print_ok[depth] = print_ok[depth-1] && is_met
            branch_taken[depth] = print_ok[depth]?1:0
          }
          else if (tag_norm ~ /^\{\{[[:space:]]*ELIF_PAGE:/) {
            sub(/^\{\{[[:space:]]*ELIF_PAGE:/,"",tag_norm); sub(/\}\}.*/,"",tag_norm)
            target=trim(tag_norm)
            can_take = print_ok[depth-1] && !branch_taken[depth]
            is_met = (target==current_page)
            print_ok[depth] = can_take && is_met
            if (print_ok[depth]) branch_taken[depth]=1
          }
          else if (tag_norm ~ /^\{\{[[:space:]]*ELSE_PAGE/) {
            can_take = print_ok[depth-1] && !branch_taken[depth]
            print_ok[depth] = can_take
            if (can_take) branch_taken[depth]=1
          }
          else if (tag_norm ~ /^\{\{[[:space:]]*ENDIF_PAGE/) {
            depth--
          }
          else {
            # unrecognized tag, print as-is
            print tag_accumulator
          }
          state=0; next
        }
        next
      }
      # print line only if all enclosing IFs allow
      if (print_ok[depth]) print line
    }
  '
}

# Handle include and include-block tags
process_includes() {
  awk -v INC_DIR="src/includes" '
    # trim whitespace
    function trim(s) { gsub(/^[[:space:]]+|[[:space:]]+$/, "", s); return s }
    # load a template file into array
    function load_template(fp, arr, n, line) {
      n=0
      while ((getline line < fp)>0) arr[++n]=line
      close(fp)
      return n
    }
    # render template arr[1..n] replacing params and {{content}}
    function render(arr,n,params,block,i,key,line,out,rest,p) {
      for(i=1;i<=n;i++){
        line=arr[i]
        for(key in params) gsub("{{"key"}}",params[key],line)
        rest=line; out=""
        while ((p=index(rest,"{{content}}"))>0) {
          out = out substr(rest,1,p-1) block
          rest = substr(rest,p+length("{{content}}"))
        }
        print out rest
      }
    }
    # parse include-block tag into filename and params
    function parse_tag(full,s,ps,key,val,eq,vs,qc,off){
      s=trim(full); gsub(/\n/," ",s)
      sub(/^.*include-block[[:space:]]*:/,"",s); sub(/\}\}.*/,"",s); s=trim(s)
      if (match(s,/^[^[:space:]]+/)) {
        filename=substr(s,RSTART,RLENGTH)
        ps=trim(substr(s,RSTART+RLENGTH))
      } else { filename=""; ps="" }
      delete params
      while(ps){
        eq=index(ps,"="); if(eq<=1) break
        key=trim(substr(ps,1,eq-1))
        qc=substr(ps,eq+1,1)
        if(qc!="\""&&qc!="\047"){
          if(match(substr(ps,eq+1),/[[:space:]]+/)){
            val=substr(ps,eq+1,RSTART-1)
            ps=trim(substr(ps,eq+1+RLENGTH))
          } else { val=substr(ps,eq+1); ps="" }
        } else {
          vs=eq+2
          off=index(substr(ps,vs),qc)
          if(!off) break
          val=substr(ps,vs,off-1)
          ps=trim(substr(ps,vs+off))
        }
        params[key]=val
      }
    }

    BEGIN { state=0; tag_acc=""; block="" }
    {
      line=$0
      if(state==0 && match(line,/\{\{[[:space:]]*(include(-block)?)/)){
        state=1; tag_acc=""; block=""
      }
      if(state==1){
        tag_acc = tag_acc (tag_acc? "\n":"") line
        if(tag_acc ~ /\}\}/){
          norm=tag_acc; gsub(/\n|[[:space:]]+/," ",norm)
          # self-contained include-block?
          if(norm ~ /\{\{[[:space:]]*include-block:.*\{\{[[:space:]]*endinclude/){
            match(tag_acc,/\{\{[[:space:]]*include-block:[^}]+\}\}/)
            st=substr(tag_acc,RSTART,RLENGTH)
            cntend=substr(tag_acc,RSTART+RLENGTH)
            sub(/\{\{[[:space:]]*endinclude.*$/,"",cntend)
            parse_tag(st)
            p=INC_DIR"/"filename
            if(system("test -f \""p"\"")==0){
              tn=load_template(p,tpl)
              render(tpl,tn,params,cntend)
            } else print tag_acc
            state=0; next
          }
          # simple include
          if(norm~/\{\{[[:space:]]*include:[^}]+\}\}/){
            match(norm,/\{\{[[:space:]]*include:[^}]+\}\}/)
            inc=substr(norm,RSTART,RLENGTH)
            f=inc; sub(/^.*include[[:space:]]*:/,"",f); sub(/\}\}.*/,"",f)
            fname=trim(f); p2=INC_DIR"/"fname
            if(system("test -f \""p2"\"")==0){
              while((getline il<p2)>0) print il
              close(p2)
            } else print inc
            state=0; next
          }
          # start include-block (no end on same line)
          if(norm~/\{\{[[:space:]]*include-block:[^}]+\}\}/){
            parse_tag(norm); state=2; next
          }
          # fallback
          print tag_acc; state=0; next
        }
        next
      }
      if(state==2){
        if(line~/\{\{[[:space:]]*endinclude/) {
          p3=INC_DIR"/"filename
          if(system("test -f \""p3"\"")==0){
            tn=load_template(p3,tpl); render(tpl,tn,params,block)
          }
          state=0; tag_acc=""; block=""; next
        } else {
          block = block (block? "\n":"") line; next
        }
      }
      if(state==0) print line
    }
  '
}

# Dedupe <style> and <script> blocks
process_styles_and_scripts() {
  awk '
    { lines[NR] = $0 }

    END {
      # Collect unique <style> blocks
      in_s=0; sb=""
      for(i=1;i<=NR;i++){
        l=lines[i]
        if(in_s){ sb=sb"\n"l
          if(l ~ /<\/[sS][tT][yY][lL][eE]>/){
            styles[sb]=1; in_s=0
          }
        } else if(l~/<[sS][tT][yY][lL][eE][^>]*>/){
          in_s=1; sb=l
        }
      }
      # Collect unique <script> blocks
      in_sc=0; scb=""
      for(i=1;i<=NR;i++){
        l=lines[i]
        if(in_sc){ scb=scb"\n"l
          if(l~/<\/[sS][cC][rR][iI][pP][tT]>/){
            scripts[scb]=1; in_sc=0
          }
        } else if(l~/<[sS][cC][rR][iI][pP][tT][^>]*>/){
          in_sc=1; scb=l
        }
      }
      # Print HTML, injecting deduped styles before </head> and scripts before </body>
      in_s=0; in_sc=0; done_h=0; done_b=0
      for(i=1;i<=NR;i++){
        l=lines[i]
        if(in_s){
          if(l~/<\/[sS][tT][yY][lL][eE]>/) in_s=0
          continue
        }
        if(in_sc){
          if(l~/<\/[sS][cC][rR][iI][pP][tT]>/) in_sc=0
          continue
        }
        if(l~/<[sS][tT][yY][lL][eE][^>]*>/){ in_s=1; continue }
        if(l~/<[sS][cC][rR][iI][pP][tT][^>]*>/){ in_sc=1; continue }
        if(l~/<\/[hH][eE][aA][dD]>/ && !done_h){
          for(s in styles) print s
          done_h=1
        }
        if(l~/<\/[bB][oO][dD][yY]>/ && !done_b){
          for(s in scripts) print s
          done_b=1
        }
        print l
      }
    }
  '
}

# Resolve "." and ".." in paths
normalize_path() {
  path="$1"; is_absolute=0; prefix=""
  case "$path" in /*) is_absolute=1; path="${path#?}"; prefix="/";; esac
  old_ifs="$IFS"; IFS='/'; set -- $path; IFS="$old_ifs"
  out=""
  for comp in "$@"; do
    if [ "$comp" = "." ] || [ -z "$comp" ]; then continue; fi
    if [ "$comp" = ".." ]; then
      if [ -n "$out" ]; then out="${out%/*}"
      elif [ "$is_absolute" -eq 0 ]; then
        out="${out:+$out/}.."
      fi
    else
      out="${out:+$out/}$comp"
    fi
  done
  if [ "$is_absolute" -eq 1 ]; then
    printf '/%s\n' "${out#/}"
  else
    printf '%s\n' "${out:-.}"
  fi
}

# Find dated files, extract metadata, sort newest-first
collect_posts() {
  find src -type f ! -path 'src/includes/*' ! -path 'src/static/*' \
    \( -name '*.md' -o -name '*.html' \) |
  while IFS= read -r file; do
    filename=${file##*/}
    case "$filename" in
      ????-??-??-*) date=${filename%%-*}; rest=${filename#*-}
                    slug=${rest%.*}; sort_key=${date//-/} ;;
      ??_??_????-*) date=${filename%%-*}; rest=${filename#*-}
                    slug=${rest%.*}; old=$IFS; IFS='_'; set -- $date
                    sort_key=$3$2$1; IFS="$old" ;;
      ??-??-????-*) date=${filename%%-*}; rest=${filename#*-}
                    slug=${rest%.*}; old=$IFS; IFS='-'; set -- $date
                    sort_key=$3$1$2; IFS="$old" ;;
      *) continue ;;
    esac
    out="dist/${file#src/}"; out="${out%.*}.html"
    # find first <img src="...">
    img=$(sed -n 's/.*<[iI][mM][gG][^>]*src=["'"'"']\([^"'"'"']*\).*/\1/p' "$file" | head -1)
    image=""
    if [ -n "$img" ]; then
      case "$img" in http://*|https://*|//*) image="$img";;
                      /*) image="${img#/}";;
                  *) np=$(normalize_path "$(dirname "$file")/$img")
                     image=${np#src/};;
      esac
    fi
    # fallback image lookup
    if [ -z "$image" ]; then
      for ext in jpg jpeg png gif webp svg; do
        p="static/posts/${slug}.${ext}"
        [ -f "src/$p" ] && { image="$p"; break; }
      done
    fi
    printf '%s|%s|%s|%s|%s\n' "$sort_key" "$date" "$slug" "$out" "$image"
  done | sort -r
}

# Output <ul> list of posts (recent or paginated)
render_posts() {
  mode=$1; cnt=$2; page=${3:-1}; pag=${4:-false}
  ucls=$5; lcls=$6; tcls=$7; xcls=$8; icls=$9; show=${10}

  all=$(collect_posts)
  total=$(printf '%s\n' "$all" | wc -l)
  total=${total##* }

  printf '<ul class="%s">\n' "$ucls"
  if [ "$mode" = "recent" ]; then
    to_show=$(printf '%s\n' "$all" | head -n "$cnt")
  else
    start=$(( (page-1)*cnt+1 )); end=$(( page*cnt ))
    to_show=$(printf '%s\n' "$all" | awk "NR>= $start && NR<= $end")
  fi
  printf '%s\n' "$to_show" | while IFS='|' read -r key date slug url img; do
    title=$(echo "$slug" | tr '-' ' ')
    printf '  <li class="%s">\n' "$lcls"
    if [ "$show" = "true" ] && [ -n "$img" ]; then
      case "$img" in http://*|https://*|//*) src="$img";;
                      *) src="/${img#*/}";;
      esac
      printf '    <img class="%s" src="%s" alt="%s">\n' "$icls" "$src" "$title"
    fi
    printf '    <time class="%s" datetime="%s">%s</time>\n' "$tcls" "$key" "$date"
    printf '    <a class="%s" href="/%s">%s</a>\n' "$xcls" "${url#dist/}" "$title"
    printf '  </li>\n'
  done
  printf '</ul>\n'

  # pagination links
  if [ "$mode" = "all" ] && [ "$pag" = "true" ] && [ "$cnt" -gt 0 ]; then
    pages=$(( (total+cnt-1)/cnt ))
    if [ "$pages" -gt 1 ]; then
      printf '<nav class="pagination">\n'
      for p in $(seq 1 $pages); do
        if [ "$p" -eq "$page" ]; then
          printf ' <span class="current">%d</span>' "$p"
        else
          printf ' <a class="page" href="?page=%d">%d</a>' "$p" "$p"
        fi
      done
      printf '\n</nav>\n'
    fi
  fi
}

# Inline {{ recent-posts }} / {{ all-posts }}
process_post_directives() {
  awk '
    # mark directive start
    /\{\{[[:space:]]*(recent-posts|all-posts)/ {
      buf=$0
      while(buf!~/\}\}/ && getline) buf=buf" "$0
      gsub(/\{\{/, "{{ ", buf); gsub(/\}\}/, " }}", buf)
      gsub(/[[:space:]]+/, " ", buf); gsub(/^ | $/, "", buf)
      print "FSSG_DIRECTIVE::" buf; next
    }
    { print }
  ' | while IFS= read -r line; do
    case "$line" in
      FSSG_DIRECTIVE::*)
        tag=${line#FSSG_DIRECTIVE::}
        dir=$(echo "$tag" | sed 's/^{{ \([^ ]*\).*/\1/')
        case "$dir" in
          recent-posts)
            cnt=$(echo "$tag" | sed -n 's/.*count="\([^"]*\)".*/\1/p')
            u=$(echo "$tag" | sed -n 's/.*ul_class="\([^"]*\)".*/\1/p')
            l=$(echo "$tag" | sed -n 's/.*li_class="\([^"]*\)".*/\1/p')
            t=$(echo "$tag" | sed -n 's/.*time_class="\([^"]*\)".*/\1/p')
            x=$(echo "$tag" | sed -n 's/.*link_class="\([^"]*\)".*/\1/p')
            i=$(echo "$tag" | sed -n 's/.*img_class="\([^"]*\)".*/\1/p')
            s=$(echo "$tag" | sed -n 's/.*show_images="\([^"]*\)".*/\1/p')
            render_posts "recent" "${cnt:-10}" 1 "false" \
                         "${u:-posts}" "${l:-post}" \
                         "${t:-date}" "${x:-title}" \
                         "${i:-thumb}" "${s:-false}"
            ;;
          all-posts)
            ps=$(echo "$tag" | sed -n 's/.*page_size="\([^"]*\)".*/\1/p')
            pg=$(echo "$tag" | sed -n 's/.*page="\([^"]*\)".*/\1/p')
            pa=$(echo "$tag" | sed -n 's/.*pagination="\([^"]*\)".*/\1/p')
            u=$(echo "$tag" | sed -n 's/.*ul_class="\([^"]*\)".*/\1/p')
            l=$(echo "$tag" | sed -n 's/.*li_class="\([^"]*\)".*/\1/p')
            t=$(echo "$tag" | sed -n 's/.*time_class="\([^"]*\)".*/\1/p')
            x=$(echo "$tag" | sed -n 's/.*link_class="\([^"]*\)".*/\1/p')
            i=$(echo "$tag" | sed -n 's/.*img_class="\([^"]*\)".*/\1/p')
            s=$(echo "$tag" | sed -n 's/.*show_images="\([^"]*\)".*/\1/p')
            render_posts "all" "${ps:-10}" "${pg:-1}" "${pa:-false}" \
                         "${u:-posts}" "${l:-post}" \
                         "${t:-date}" "${x:-title}" \
                         "${i:-thumb}" "${s:-false}"
            ;;
          *) printf '%s\n' "$tag" ;;
        esac
        ;;
      *) printf '%s\n' "$line" ;;
    esac
  done
}

# Full pipeline for each source file
process_file() {
  file="$1"; ext="${file##*.}"
  rel="${file#src/}"; out="dist/${rel%.*}.html"
  mkdir -p "$(dirname "$out")"
  log_verbose "Processing $file -> $out"

  # generate or override title
  base=$(basename "$file" ."$ext")
  dyn=$(printf '%s\n' "$base"|tr '-' ' '|awk '{for(i=1;i<=NF;i++)$i=toupper(substr($i,1,1))tolower(substr($i,2));print}')
  pid="${rel%.*}.html"

  if [ "$ext" = "md" ]; then
    raw=$(parse_markdown<"$file")
  else
    raw=$(cat "$file")
  fi
  override=$(printf '%s\n' "$raw"|awk '/\{\{ *[Tt][Ii][Tt][Ll][Ee]:/ {sub(/.*\{\{.*:/,"");sub(/\}\}.*/,"");print;exit}')
  title="${override:-$dyn}"

  tpl="src/template.html"; [ ! -f "$tpl" ] && tpl="/dev/null"

  printf '%s\n' "$raw" \
    | sed 's/{{ *[Tt][Ii][Tt][Ll][Ee]:[^}]*}}//g' \
    | apply_template "$tpl" "$title" \
    | process_conditionals "$pid" "$ext" \
    | process_includes \
    | process_post_directives \
    | process_styles_and_scripts >"$out"

  log_info "Created $out"
}

# Orchestrate full build and asset copy
build_site() {
  log_info "Starting build..."
  rm -rf dist; mkdir -p dist
  jobs=0
  find src \( -path src/includes -o -name template.html -o -path src/static \) -prune -o \
    -type f \( -name '*.md' -o -name '*.html' \) -print |
  while IFS= read -r f; do
    process_file "$f" & jobs=$((jobs+1))
    [ "$jobs" -ge "$MAX_JOBS" ] && wait && jobs=0
  done
  wait

  mkdir -p dist/static; found=0
  for d in src/static static; do
    [ -d "$d" ] && cp -a "$d/." dist/static/ && log_info "Copied $d -> dist/static/" && found=1
  done
  [ "$found" -eq 0 ] && log_warn "No static directory found; skipping."

  log_info "${GREEN}Build complete!${NC}"
}

# Choose the correct Mongoose binary for the current OS and launch it,
# serving the dist/ directory at http://localhost:8000.
start_server() {
	case "$(uname -s)" in
		CYGWIN*|MINGW*|MSYS*) MONGOOSE_BIN="./mongoose/mongoose_windows.exe" ;;
		Linux*) MONGOOSE_BIN="./mongoose/mongoose_linux" ;;
		Darwin*) MONGOOSE_BIN="./mongoose/mongoose_mac" ;;
		*) MONGOOSE_BIN="./mongoose/mongoose_linux" ;;
	esac
	if [ ! -x "$MONGOOSE_BIN" ]; then
		log_error "Mongoose binary not found or not executable."
		exit 1
	fi
	log_info "Starting server at http://localhost:8000"
	"$MONGOOSE_BIN" -d dist/ -v 0 &
	SERVER_PID=$!
}

# Open the default web browser to http://localhost:8000, depending on OS.
open_browser() {
   url="http://localhost:8000"
   case "$(uname -s)" in
     Darwin*)
       open "$url" >/dev/null 2>&1 &
       ;;
     Linux*)
       xdg-open "$url" >/dev/null 2>&1 &
       ;;
     CYGWIN*|MINGW*|MSYS*)
       start "$url" >/dev/null 2>&1 &
       ;;
     *)
       log_info "Please open $url in your browser."
       ;;
   esac
 }

# Show help info... Duh
display_help() {
  cat <<EOF
  fssg - Fast, Simple Static Site Generator
  -----------------------------------------

  Usage:
    $0 [options]

  Options:
    -h          Display this help message
    -q          Suppress all output except errors
    -v          Show detailed build information
    -n          Disable colored output
    -w          Watch for changes and rebuild automatically
    -s          Start a local server for the dist/ directory
    -o          Open the browser automatically (requires -s)
    -j <num>    Number of parallel jobs (default: 4)
EOF
}

# -----------------------------------------------------------------------------------------
# Entrypoint and main control flow
# -----------------------------------------------------------------------------------------

# Default settings for command-line flags
QUIET=0
VERBOSE=0
MAX_JOBS=4
WATCH=0
SERVE=0
OPEN_BROWSER=0
NO_COLOR=0
SERVER_PID=""

# Parse command-line options (POSIX getopts)
while getopts "hqvwnsoj:" opt; do
	case "$opt" in
		h) display_help; exit 0 ;;
		q) QUIET=1; VERBOSE=0 ;;
		v) VERBOSE=1; QUIET=0 ;;
		w) WATCH=1 ;;
		n) NO_COLOR=1 ;;
		s) SERVE=1 ;;
		o) OPEN_BROWSER=1 ;;
		j) MAX_JOBS="$OPTARG" ;;
		*) display_help; exit 1 ;;
	esac
done

if [ "$NO_COLOR" -eq 1 ] || ! [ -t 1 ]; then
	GREEN="" RED="" YELLOW="" BLUE="" NC=""
else
	GREEN=$(printf '\033[0;32m')
	RED=$(printf '\033[0;31m')
	YELLOW=$(printf '\033[0;33m')
	BLUE=$(printf '\033[0;34m')
	NC=$(printf '\033[0m')
fi

# Ensure the Mongoose server (if started) is killed when the script exits.
trap 'if [ -n "$SERVER_PID" ]; then kill "$SERVER_PID"; fi' EXIT

if [ "$WATCH" -eq 1 ]; then
  build_site
  if [ "$SERVE" -eq 1 ]; then
    start_server
    [ "$OPEN_BROWSER" -eq 1 ] && open_browser
  fi

  last_hash=$(find src -type f -exec cksum {} + | cksum)
  while true; do
    sleep 1
    current_hash=$(find src -type f -exec cksum {} + | cksum)
    if [ "$current_hash" != "$last_hash" ]; then
      log_info "Change detected, rebuilding..."
      build_site
      last_hash="$current_hash"
    fi
  done
else
  build_site
  if [ "$SERVE" -eq 1 ]; then
    start_server
    [ "$OPEN_BROWSER" -eq 1 ] && open_browser
    log_info "Server is running at http://localhost:8000 (Press Ctrl+C to stop)"
    wait "$SERVER_PID"
  fi
fi

exit 0